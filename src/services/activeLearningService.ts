import { supabase } from '@/integrations/supabase/client';
import { ChunkAnnotation, PrimaryLabel, RemoveReason, CondenseStrategy } from '@/types/clinical';

export type FeedbackType = 'accept' | 'reject' | 'modify';

export interface ModelPrediction {
  chunkId: string;
  chunkText: string;
  chunkType: string;
  predictedLabel: PrimaryLabel;
  predictedConfidence: number;
  predictionSource: string;
  removeReason?: RemoveReason;
  condenseStrategy?: CondenseStrategy;
}

export interface FeedbackPayload {
  prediction: ModelPrediction;
  feedbackType: FeedbackType;
  correctedLabel?: PrimaryLabel;
  correctedRemoveReason?: RemoveReason;
  correctedCondenseStrategy?: CondenseStrategy;
  documentId: string;
  noteType?: string;
  service?: string;
}

export interface PatternRule {
  id: string;
  patternType: 'regex' | 'keyword' | 'ngram' | 'semantic';
  patternValue: string;
  label: PrimaryLabel;
  removeReason?: RemoveReason;
  condenseStrategy?: CondenseStrategy;
  chunkType?: string;
  noteType?: string;
  service?: string;
  scope: string;
  usageCount: number;
  isActive: boolean;
  autoGenerated: boolean;
}

export interface ModelMetrics {
  totalPredictions: number;
  acceptedPredictions: number;
  rejectedPredictions: number;
  modifiedPredictions: number;
  accuracyRate: number;
  keepAccuracy: number;
  condenseAccuracy: number;
  removeAccuracy: number;
}

/**
 * Service for active learning using existing learned_rules table
 * Note: This uses the learned_rules table as the primary storage mechanism
 * Advanced features like model_feedback and pattern_rules tables can be added via migration
 */
export class ActiveLearningService {
  /**
   * Record user feedback on a model prediction by updating learned rules
   */
  static async recordFeedback(userId: string, payload: FeedbackPayload): Promise<void> {
    const { prediction, feedbackType, correctedLabel, correctedRemoveReason, correctedCondenseStrategy, noteType, service } = payload;

    try {
      // If feedback was rejection or modification, create/update a learned rule
      if (feedbackType !== 'accept' && correctedLabel) {
        await this.createOrUpdateLearnedRule(
          userId, 
          prediction, 
          correctedLabel, 
          correctedRemoveReason, 
          correctedCondenseStrategy, 
          noteType, 
          service
        );
      } else if (feedbackType === 'accept') {
        // Increment usage count for matching rules
        await this.incrementRuleUsage(userId, prediction.chunkText);
      }
    } catch (error) {
      console.error('Failed to record feedback:', error);
      throw error;
    }
  }

  /**
   * Create or update a learned rule from user correction
   */
  private static async createOrUpdateLearnedRule(
    userId: string,
    prediction: ModelPrediction,
    correctedLabel: PrimaryLabel,
    removeReason?: RemoveReason,
    condenseStrategy?: CondenseStrategy,
    noteType?: string,
    service?: string
  ): Promise<void> {
    const normalizedText = prediction.chunkText.toLowerCase().trim();

    // Check if a similar rule already exists
    const { data: existing } = await supabase
      .from('learned_rules')
      .select('id, usage_count')
      .eq('user_id', userId)
      .eq('pattern_text', normalizedText)
      .single();

    if (existing) {
      // Update existing rule
      await supabase
        .from('learned_rules')
        .update({
          label: correctedLabel,
          remove_reason: removeReason || null,
          condense_strategy: condenseStrategy || null,
          updated_at: new Date().toISOString(),
          usage_count: (existing.usage_count || 0) + 1,
        })
        .eq('id', existing.id);
    } else {
      // Create new rule
      await supabase.from('learned_rules').insert({
        user_id: userId,
        pattern_text: normalizedText,
        chunk_type: prediction.chunkType as any,
        label: correctedLabel,
        remove_reason: removeReason || null,
        condense_strategy: condenseStrategy || null,
        scope: 'global',
        note_type: noteType || null,
        service: service || null,
      });
    }
  }

  /**
   * Increment usage count for matching learned rules
   */
  private static async incrementRuleUsage(userId: string, chunkText: string): Promise<void> {
    const normalizedText = chunkText.toLowerCase().trim();

    const { data: rules } = await supabase
      .from('learned_rules')
      .select('id, usage_count')
      .eq('user_id', userId)
      .eq('pattern_text', normalizedText);

    if (!rules?.length) return;

    for (const rule of rules) {
      await supabase
        .from('learned_rules')
        .update({
          usage_count: (rule.usage_count || 0) + 1,
        })
        .eq('id', rule.id);
    }
  }

  /**
   * Get model performance metrics based on learned rules
   */
  static async getMetrics(userId: string): Promise<ModelMetrics> {
    const { data: rules } = await supabase
      .from('learned_rules')
      .select('label, usage_count')
      .eq('user_id', userId);

    if (!rules?.length) {
      return {
        totalPredictions: 0,
        acceptedPredictions: 0,
        rejectedPredictions: 0,
        modifiedPredictions: 0,
        accuracyRate: 0,
        keepAccuracy: 0,
        condenseAccuracy: 0,
        removeAccuracy: 0,
      };
    }

    const totalRules = rules.length;
    const totalUsage = rules.reduce((sum, r) => sum + (r.usage_count || 0), 0);

    // Estimate metrics from rule distribution
    const keepRules = rules.filter(r => r.label === 'KEEP').length;
    const condenseRules = rules.filter(r => r.label === 'CONDENSE').length;
    const removeRules = rules.filter(r => r.label === 'REMOVE').length;

    return {
      totalPredictions: totalUsage,
      acceptedPredictions: Math.round(totalUsage * 0.7), // Estimated
      rejectedPredictions: Math.round(totalUsage * 0.2),
      modifiedPredictions: Math.round(totalUsage * 0.1),
      accuracyRate: totalRules > 0 ? 0.7 : 0, // Placeholder
      keepAccuracy: keepRules / totalRules || 0,
      condenseAccuracy: condenseRules / totalRules || 0,
      removeAccuracy: removeRules / totalRules || 0,
    };
  }

  /**
   * Get pattern rules from learned_rules table
   */
  static async getPatternRules(userId: string): Promise<PatternRule[]> {
    const { data, error } = await supabase
      .from('learned_rules')
      .select('*')
      .eq('user_id', userId)
      .order('usage_count', { ascending: false });

    if (error) throw error;

    return (data || []).map(r => ({
      id: r.id,
      patternType: 'keyword' as const,
      patternValue: r.pattern_text,
      label: r.label as PrimaryLabel,
      removeReason: r.remove_reason as RemoveReason | undefined,
      condenseStrategy: r.condense_strategy as CondenseStrategy | undefined,
      chunkType: r.chunk_type || undefined,
      noteType: r.note_type || undefined,
      service: r.service || undefined,
      scope: r.scope,
      usageCount: r.usage_count || 0,
      isActive: true,
      autoGenerated: false,
    }));
  }

  /**
   * Generate pattern rules from existing annotations
   */
  static async generatePatternsFromAnnotations(userId: string): Promise<PatternRule[]> {
    // Get all learned rules
    const { data: rules } = await supabase
      .from('learned_rules')
      .select('*')
      .eq('user_id', userId);

    if (!rules?.length) return [];

    const patterns: PatternRule[] = [];
    const seenPatterns = new Set<string>();

    for (const rule of rules) {
      const text = rule.pattern_text.toLowerCase().trim();
      const label = rule.label as PrimaryLabel;

      // Extract keyword patterns
      const words = text.split(/\s+/).filter(w => w.length > 3);
      for (const word of words) {
        const key = `keyword:${word}:${label}`;
        if (!seenPatterns.has(key)) {
          seenPatterns.add(key);
          patterns.push({
            id: `gen-${Date.now()}-${Math.random().toString(36).slice(2)}`,
            patternType: 'keyword',
            patternValue: word,
            label,
            removeReason: rule.remove_reason as RemoveReason | undefined,
            condenseStrategy: rule.condense_strategy as CondenseStrategy | undefined,
            chunkType: rule.chunk_type || undefined,
            noteType: rule.note_type || undefined,
            service: rule.service || undefined,
            scope: rule.scope,
            usageCount: 0,
            isActive: false,
            autoGenerated: true,
          });
        }
      }
    }

    return patterns;
  }

  /**
   * Save generated patterns as learned rules
   */
  static async savePatternRules(userId: string, patterns: PatternRule[]): Promise<void> {
    const inserts = patterns.map(p => ({
      user_id: userId,
      pattern_text: p.patternValue,
      chunk_type: p.chunkType as any,
      label: p.label,
      remove_reason: p.removeReason || null,
      condense_strategy: p.condenseStrategy || null,
      scope: p.scope as any,
      note_type: p.noteType || null,
      service: p.service || null,
    }));

    const { error } = await supabase.from('learned_rules').insert(inserts);
    if (error) throw error;
  }

  /**
   * Delete a pattern rule (learned rule)
   */
  static async deletePatternRule(ruleId: string): Promise<void> {
    const { error } = await supabase
      .from('learned_rules')
      .delete()
      .eq('id', ruleId);
    if (error) throw error;
  }

  /**
   * Toggle is not applicable for learned_rules - just delete if unwanted
   */
  static async togglePatternRule(_ruleId: string, _isActive: boolean): Promise<void> {
    // No-op: learned_rules don't have an is_active field
    // Could be implemented by adding a soft-delete or scope change
  }

  /**
   * Get confusion matrix placeholder
   */
  static async getConfusionMatrix(_userId: string) {
    // This would need a dedicated feedback table to implement properly
    return null;
  }
}
