import { supabase } from '@/integrations/supabase/client';
import { ChunkAnnotation, DocumentChunk, PrimaryLabel, RemoveReason, CondenseStrategy } from '@/types/clinical';
import { ModelExplanation } from '@/utils/inferenceModel';

export type FeedbackType = 'accept' | 'reject' | 'modify';

export interface ModelPrediction {
  chunkId: string;
  chunkText: string;
  chunkType: string;
  predictedLabel: PrimaryLabel;
  predictedConfidence: number;
  predictionSource: string;
  removeReason?: RemoveReason;
  condenseStrategy?: CondenseStrategy;
}

export interface FeedbackPayload {
  prediction: ModelPrediction;
  feedbackType: FeedbackType;
  correctedLabel?: PrimaryLabel;
  correctedRemoveReason?: RemoveReason;
  correctedCondenseStrategy?: CondenseStrategy;
  documentId: string;
  noteType?: string;
  service?: string;
}

export interface PatternRule {
  id: string;
  patternType: 'regex' | 'keyword' | 'ngram' | 'semantic';
  patternValue: string;
  label: PrimaryLabel;
  removeReason?: RemoveReason;
  condenseStrategy?: CondenseStrategy;
  chunkType?: string;
  noteType?: string;
  service?: string;
  scope: string;
  timesMatched: number;
  timesAccepted: number;
  effectivenessScore: number;
  isActive: boolean;
  autoGenerated: boolean;
}

export interface ModelMetrics {
  totalPredictions: number;
  acceptedPredictions: number;
  rejectedPredictions: number;
  modifiedPredictions: number;
  accuracyRate: number;
  keepAccuracy: number;
  condenseAccuracy: number;
  removeAccuracy: number;
}

/**
 * Service for active learning and model feedback management
 */
export class ActiveLearningService {
  /**
   * Record user feedback on a model prediction
   */
  static async recordFeedback(userId: string, payload: FeedbackPayload): Promise<void> {
    const { prediction, feedbackType, correctedLabel, correctedRemoveReason, correctedCondenseStrategy, documentId, noteType, service } = payload;

    try {
      await supabase.from('model_feedback').insert({
        user_id: userId,
        chunk_id: prediction.chunkId,
        document_id: documentId,
        predicted_label: prediction.predictedLabel,
        predicted_confidence: prediction.predictedConfidence,
        prediction_source: prediction.predictionSource,
        corrected_label: correctedLabel,
        corrected_remove_reason: correctedRemoveReason,
        corrected_condense_strategy: correctedCondenseStrategy,
        feedback_type: feedbackType,
        chunk_text: prediction.chunkText,
        chunk_type: prediction.chunkType,
        note_type: noteType,
        service,
      });

      // If feedback was rejection or modification, potentially create a new learned rule
      if (feedbackType !== 'accept' && correctedLabel) {
        await this.maybeCreateLearnedRule(userId, prediction, correctedLabel, correctedRemoveReason, correctedCondenseStrategy, noteType, service);
      }

      // Update effectiveness scores for matching rules
      await this.updateRuleEffectiveness(userId, prediction, feedbackType === 'accept');
    } catch (error) {
      console.error('Failed to record feedback:', error);
      throw error;
    }
  }

  /**
   * Create a learned rule from user correction
   */
  private static async maybeCreateLearnedRule(
    userId: string,
    prediction: ModelPrediction,
    correctedLabel: PrimaryLabel,
    removeReason?: RemoveReason,
    condenseStrategy?: CondenseStrategy,
    noteType?: string,
    service?: string
  ): Promise<void> {
    const normalizedText = prediction.chunkText.toLowerCase().trim();

    // Check if a similar rule already exists
    const { data: existing } = await supabase
      .from('learned_rules')
      .select('id')
      .eq('user_id', userId)
      .eq('pattern_text', normalizedText)
      .single();

    if (existing) {
      // Update existing rule
      await supabase
        .from('learned_rules')
        .update({
          label: correctedLabel,
          remove_reason: removeReason,
          condense_strategy: condenseStrategy,
          updated_at: new Date().toISOString(),
          usage_count: supabase.rpc ? 1 : 1, // Increment would need RPC
        })
        .eq('id', existing.id);
    } else {
      // Create new rule
      await supabase.from('learned_rules').insert({
        user_id: userId,
        pattern_text: normalizedText,
        chunk_type: prediction.chunkType,
        label: correctedLabel,
        remove_reason: removeReason,
        condense_strategy: condenseStrategy,
        scope: 'global',
        note_type: noteType,
        service,
      });
    }
  }

  /**
   * Update effectiveness scores for rules that matched this prediction
   */
  private static async updateRuleEffectiveness(
    userId: string,
    prediction: ModelPrediction,
    wasAccepted: boolean
  ): Promise<void> {
    // Find rules that might have contributed to this prediction
    const normalizedText = prediction.chunkText.toLowerCase().trim();

    const { data: rules } = await supabase
      .from('learned_rules')
      .select('id, times_matched, times_accepted, effectiveness_score')
      .eq('user_id', userId)
      .textSearch('pattern_text', normalizedText.split(' ').slice(0, 5).join(' | '));

    if (!rules?.length) return;

    for (const rule of rules) {
      const newTimesMatched = (rule.times_matched || 0) + 1;
      const newTimesAccepted = (rule.times_accepted || 0) + (wasAccepted ? 1 : 0);
      const newEffectiveness = newTimesAccepted / newTimesMatched;

      await supabase
        .from('learned_rules')
        .update({
          times_matched: newTimesMatched,
          times_accepted: newTimesAccepted,
          effectiveness_score: Math.round(newEffectiveness * 1000) / 1000,
        })
        .eq('id', rule.id);
    }
  }

  /**
   * Get model performance metrics for a user
   */
  static async getMetrics(userId: string): Promise<ModelMetrics> {
    const { data: feedback } = await supabase
      .from('model_feedback')
      .select('feedback_type, predicted_label, corrected_label')
      .eq('user_id', userId);

    if (!feedback?.length) {
      return {
        totalPredictions: 0,
        acceptedPredictions: 0,
        rejectedPredictions: 0,
        modifiedPredictions: 0,
        accuracyRate: 0,
        keepAccuracy: 0,
        condenseAccuracy: 0,
        removeAccuracy: 0,
      };
    }

    const total = feedback.length;
    const accepted = feedback.filter(f => f.feedback_type === 'accept').length;
    const rejected = feedback.filter(f => f.feedback_type === 'reject').length;
    const modified = feedback.filter(f => f.feedback_type === 'modify').length;

    // Per-label accuracy
    const keepTotal = feedback.filter(f => f.predicted_label === 'KEEP').length;
    const keepCorrect = feedback.filter(f => f.predicted_label === 'KEEP' && f.feedback_type === 'accept').length;

    const condenseTotal = feedback.filter(f => f.predicted_label === 'CONDENSE').length;
    const condenseCorrect = feedback.filter(f => f.predicted_label === 'CONDENSE' && f.feedback_type === 'accept').length;

    const removeTotal = feedback.filter(f => f.predicted_label === 'REMOVE').length;
    const removeCorrect = feedback.filter(f => f.predicted_label === 'REMOVE' && f.feedback_type === 'accept').length;

    return {
      totalPredictions: total,
      acceptedPredictions: accepted,
      rejectedPredictions: rejected,
      modifiedPredictions: modified,
      accuracyRate: total > 0 ? accepted / total : 0,
      keepAccuracy: keepTotal > 0 ? keepCorrect / keepTotal : 0,
      condenseAccuracy: condenseTotal > 0 ? condenseCorrect / condenseTotal : 0,
      removeAccuracy: removeTotal > 0 ? removeCorrect / removeTotal : 0,
    };
  }

  /**
   * Get pattern rules for a user
   */
  static async getPatternRules(userId: string): Promise<PatternRule[]> {
    const { data, error } = await supabase
      .from('pattern_rules')
      .select('*')
      .eq('user_id', userId)
      .eq('is_active', true)
      .order('effectiveness_score', { ascending: false });

    if (error) throw error;

    return (data || []).map(r => ({
      id: r.id,
      patternType: r.pattern_type as PatternRule['patternType'],
      patternValue: r.pattern_value,
      label: r.label as PrimaryLabel,
      removeReason: r.remove_reason as RemoveReason | undefined,
      condenseStrategy: r.condense_strategy as CondenseStrategy | undefined,
      chunkType: r.chunk_type || undefined,
      noteType: r.note_type || undefined,
      service: r.service || undefined,
      scope: r.scope,
      timesMatched: r.times_matched,
      timesAccepted: r.times_accepted,
      effectivenessScore: Number(r.effectiveness_score),
      isActive: r.is_active,
      autoGenerated: r.auto_generated,
    }));
  }

  /**
   * Generate pattern rules from user annotations
   */
  static async generatePatternsFromAnnotations(userId: string): Promise<PatternRule[]> {
    // Get all feedback with corrections
    const { data: feedback } = await supabase
      .from('model_feedback')
      .select('*')
      .eq('user_id', userId)
      .in('feedback_type', ['reject', 'modify']);

    if (!feedback?.length) return [];

    const patterns: PatternRule[] = [];
    const seenPatterns = new Set<string>();

    for (const f of feedback) {
      const text = f.chunk_text.toLowerCase().trim();
      const label = (f.corrected_label || f.predicted_label) as PrimaryLabel;

      // Extract keyword patterns (words that appear frequently in corrections)
      const words = text.split(/\s+/).filter(w => w.length > 3);
      for (const word of words) {
        const key = `keyword:${word}:${label}`;
        if (!seenPatterns.has(key)) {
          seenPatterns.add(key);
          patterns.push({
            id: `gen-${Date.now()}-${Math.random().toString(36).slice(2)}`,
            patternType: 'keyword',
            patternValue: word,
            label,
            removeReason: f.corrected_remove_reason as RemoveReason | undefined,
            condenseStrategy: f.corrected_condense_strategy as CondenseStrategy | undefined,
            chunkType: f.chunk_type,
            noteType: f.note_type || undefined,
            service: f.service || undefined,
            scope: 'global',
            timesMatched: 0,
            timesAccepted: 0,
            effectivenessScore: 0.5,
            isActive: false, // Start inactive until user enables
            autoGenerated: true,
          });
        }
      }

      // Extract n-gram patterns (2-3 word phrases)
      const ngrams: string[] = [];
      for (let i = 0; i < words.length - 1; i++) {
        ngrams.push(`${words[i]} ${words[i + 1]}`);
        if (i < words.length - 2) {
          ngrams.push(`${words[i]} ${words[i + 1]} ${words[i + 2]}`);
        }
      }

      for (const ngram of ngrams) {
        const key = `ngram:${ngram}:${label}`;
        if (!seenPatterns.has(key)) {
          seenPatterns.add(key);
          patterns.push({
            id: `gen-${Date.now()}-${Math.random().toString(36).slice(2)}`,
            patternType: 'ngram',
            patternValue: ngram,
            label,
            removeReason: f.corrected_remove_reason as RemoveReason | undefined,
            condenseStrategy: f.corrected_condense_strategy as CondenseStrategy | undefined,
            chunkType: f.chunk_type,
            noteType: f.note_type || undefined,
            service: f.service || undefined,
            scope: 'global',
            timesMatched: 0,
            timesAccepted: 0,
            effectivenessScore: 0.5,
            isActive: false,
            autoGenerated: true,
          });
        }
      }
    }

    return patterns;
  }

  /**
   * Save generated patterns to database
   */
  static async savePatternRules(userId: string, patterns: PatternRule[]): Promise<void> {
    const inserts = patterns.map(p => ({
      user_id: userId,
      pattern_type: p.patternType,
      pattern_value: p.patternValue,
      label: p.label,
      remove_reason: p.removeReason,
      condense_strategy: p.condenseStrategy,
      chunk_type: p.chunkType,
      note_type: p.noteType,
      service: p.service,
      scope: p.scope,
      is_active: p.isActive,
      auto_generated: p.autoGenerated,
    }));

    const { error } = await supabase.from('pattern_rules').insert(inserts);
    if (error) throw error;
  }

  /**
   * Toggle a pattern rule's active status
   */
  static async togglePatternRule(ruleId: string, isActive: boolean): Promise<void> {
    const { error } = await supabase
      .from('pattern_rules')
      .update({ is_active: isActive, updated_at: new Date().toISOString() })
      .eq('id', ruleId);
    if (error) throw error;
  }

  /**
   * Delete a pattern rule
   */
  static async deletePatternRule(ruleId: string): Promise<void> {
    const { error } = await supabase
      .from('pattern_rules')
      .delete()
      .eq('id', ruleId);
    if (error) throw error;
  }

  /**
   * Get feedback history for analysis
   */
  static async getFeedbackHistory(
    userId: string,
    options: { limit?: number; feedbackType?: FeedbackType } = {}
  ) {
    let query = supabase
      .from('model_feedback')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false });

    if (options.feedbackType) {
      query = query.eq('feedback_type', options.feedbackType);
    }

    if (options.limit) {
      query = query.limit(options.limit);
    }

    const { data, error } = await query;
    if (error) throw error;
    return data || [];
  }

  /**
   * Get confusion matrix data for analysis
   */
  static async getConfusionMatrix(userId: string) {
    const { data } = await supabase
      .from('model_feedback')
      .select('predicted_label, corrected_label, feedback_type')
      .eq('user_id', userId);

    if (!data?.length) return null;

    const matrix: Record<string, Record<string, number>> = {
      KEEP: { KEEP: 0, CONDENSE: 0, REMOVE: 0 },
      CONDENSE: { KEEP: 0, CONDENSE: 0, REMOVE: 0 },
      REMOVE: { KEEP: 0, CONDENSE: 0, REMOVE: 0 },
    };

    for (const f of data) {
      const predicted = f.predicted_label as string;
      const actual = f.feedback_type === 'accept'
        ? predicted
        : (f.corrected_label || predicted) as string;

      if (matrix[predicted] && matrix[predicted][actual] !== undefined) {
        matrix[predicted][actual]++;
      }
    }

    return matrix;
  }
}
